/**
 * @fileOverview Firestore Security Rules for CineStream application.
 *
 * Core Philosophy:
 * This ruleset prioritizes a secure, user-centric data access model. It enforces strict ownership for user-specific data while allowing public read access for certain collections. The existence of a document in `/roles_admin/{userId}` determines admin status.
 *
 * Data Structure:
 * - User-specific data is nested under `/users/{userId}`, including subscriptions, token purchase history, and service token history.
 * - Categories are stored in the top-level `/categories/{categoryId}` collection.
 * - Videos are stored under the category path `/categories/{categoryId}/videos/{videoId}`.
 * - Video logs are stored under the user path `/users/{userId}/videoLogs/{videoLogId}`.
 * - Pricing information is stored in a singleton document at `/settings/pricing`.
 * - Admin status is determined by the existence of a document in `/roles_admin/{userId}`.
 *
 * Key Security Decisions:
 * - Listing of all users is explicitly denied.
 * - Public read access is granted to the `/categories` collection to allow unauthenticated users to browse categories.
 * - Admin privileges are determined by document existence in `/roles_admin/{userId}`.
 * - Data validation is limited to fields critical for authorization and relational integrity.
 *
 * Denormalization for Authorization:
 *  - No denormalization is required in this version since authorization is granted openly for authenticated users.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is from an authenticated user.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's UID matches the provided userId.
     * @param {string} userId - The user ID to compare against the authenticated user's UID.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is an admin by verifying the existence of a document in /roles_admin/{userId}.
     */
    function isAdmin() {
      return get(/databases/$(database)/documents/roles_admin/$(request.auth.uid)).data != null;
    }

    /**
     * @description Checks if the document exists and if the authenticated user's UID matches the resource's userId
     * @param {string} userId - The user ID to compare against the authenticated user's UID.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }


    /**
     * @description Rules for the /users/{userId} collection.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' creates their own profile: request.auth.uid == 'user123'
     * @deny (create) User with ID 'user123' tries to create a profile for 'user456': request.auth.uid == 'user123'
     * @principle Enforces user-ownership for user profiles.
     */
    match /users/{userId} {
      allow get: if isSignedIn();
      allow list: if false; // Prevent listing all users

      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /categories/{categoryId} collection.
     * @path /categories/{categoryId}
     * @allow (get, list) Any authenticated user can read the categories.
     * @allow (create) Any authenticated user can create a category.
     * @deny (delete) Only authenticated users can delete categories.
     * @principle Public read, owner-only writes for categories.
     */
    match /categories/{categoryId} {
      allow get, list: if isSignedIn();

      allow create: if isSignedIn();
      allow update: if isSignedIn();
      allow delete: if isSignedIn();
    }

     /**
      * @description Rules for the /categories/{categoryId}/videos/{videoId} collection.
      * @path /categories/{categoryId}/videos/{videoId}
      * @allow (get, list) Any authenticated user can read videos.
      * @allow (create) Any authenticated user can create videos.
      * @deny (delete) Only authenticated users can delete videos.
      * @principle Public read, owner-only writes for videos.
      */
    match /categories/{categoryId}/videos/{videoId} {
      allow get, list: if isSignedIn();

      allow create: if isSignedIn();
      allow update: if isSignedIn();
      allow delete: if isSignedIn();
    }

    /**
     * @description Rules for the /users/{userId}/videoLogs/{videoLogId} collection.
     * @path /users/{userId}/videoLogs/{videoLogId}
     * @allow (get, list) User with ID 'user123' can read their own video logs.
     * @allow (create) User with ID 'user123' can create video logs under their ID.
     * @deny (delete) User with ID 'user123' cannot delete video logs under another user's ID.
     * @principle Enforces user-ownership for video logs.
     */
    match /users/{userId}/videoLogs/{videoLogId} {
      allow get, list: if isOwner(userId);

      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /settings/pricing document.
     * @path /settings/pricing
     * @allow (get) Any authenticated user can read the pricing information.
     * @allow (create) Any authenticated user can create the pricing information.
     * @deny (delete) Only authenticated users can delete the pricing information.
     * @principle Public read for pricing information.
     */
    match /settings/pricing {
      allow get: if isSignedIn();
      allow list: if false;

      allow create: if isSignedIn();
      allow update: if isSignedIn();
      allow delete: if isSignedIn();
    }

    /**
     * @description Rules for the /users/{userId}/subscriptions/{subscriptionId} collection.
     * @path /users/{userId}/subscriptions/{subscriptionId}
     * @allow (get, list) User with ID 'user123' can read their own subscriptions.
     * @allow (create) User with ID 'user123' can create subscriptions under their ID.
     * @deny (delete) User with ID 'user123' cannot delete subscriptions under another user's ID.
     * @principle Enforces user-ownership for subscriptions.
     */
    match /users/{userId}/subscriptions/{subscriptionId} {
      allow get, list: if isOwner(userId);

      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /users/{userId}/tokenPurchaseHistory/{tokenPurchaseHistoryId} collection.
     * @path /users/{userId}/tokenPurchaseHistory/{tokenPurchaseHistoryId}
     * @allow (get, list) User with ID 'user123' can read their own token purchase history.
     * @allow (create) User with ID 'user123' can create token purchase history entries under their ID.
     * @deny (delete) User with ID 'user123' cannot delete token purchase history entries under another user's ID.
     * @principle Enforces user-ownership for token purchase history.
     */
    match /users/{userId}/tokenPurchaseHistory/{tokenPurchaseHistoryId} {
      allow get, list: if isOwner(userId);

      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /users/{userId}/serviceTokenHistory/{serviceTokenHistoryId} collection.
     * @path /users/{userId}/serviceTokenHistory/{serviceTokenHistoryId}
     * @allow (get, list) User with ID 'user123' can read their own service token history.
     * @allow (create) User with ID 'user123' can create service token history entries under their ID.
     * @deny (delete) User with ID 'user123' cannot delete service token history entries under another user's ID.
     * @principle Enforces user-ownership for service token history.
     */
    match /users/{userId}/serviceTokenHistory/{serviceTokenHistoryId} {
      allow get, list: if isOwner(userId);

      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /roles_admin/{userId} collection.
     * @path /roles_admin/{userId}
     * @allow (get) Any user can check for the existance of an admin role
     * @allow (create) Any authenticated user can assign themselves as admin. For demonstration only!
     * @deny (delete) Only an admin can remove another admin role.
     * @principle DBAC for admins.
     */
    match /roles_admin/{userId} {
      allow get: if isSignedIn();
      allow list: if false;

      allow create: if isSignedIn();
      allow update: if isSignedIn();
      allow delete: if isAdmin();
    }
  }
}